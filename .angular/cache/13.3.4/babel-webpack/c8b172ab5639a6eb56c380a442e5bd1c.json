{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sheme\\\\Documents\\\\GitHub\\\\aorta_new_website\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { delay, filter, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class ObserveVisibilityDirective {\n  constructor(element) {\n    this.element = element;\n    this.debounceTime = 0;\n    this.threshold = 1;\n    this.visible = new EventEmitter();\n    this.invisible = new EventEmitter();\n    this.subject$ = new Subject();\n  }\n\n  ngOnInit() {\n    this.createObserver();\n  }\n\n  ngAfterViewInit() {\n    this.startObservingElements();\n  }\n\n  ngOnDestroy() {\n    console.log('ngOnDestroy');\n\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    } // this.subject$.next();\n\n\n    this.subject$.complete();\n  }\n\n  isVisible(element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        resolve(entry.intersectionRatio === 1);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  }\n\n  createObserver() {\n    const options = {\n      rootMargin: '0px',\n      threshold: this.threshold\n    };\n\n    const isIntersecting = entry => entry.isIntersecting || entry.intersectionRatio > 0;\n\n    this.observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (isIntersecting(entry)) {\n          this.subject$.next({\n            entry,\n            observer\n          });\n        }\n      });\n    }, options);\n  }\n\n  startObservingElements() {\n    var _this = this;\n\n    if (!this.observer) {\n      return;\n    }\n\n    this.observer.observe(this.element.nativeElement);\n    this.subject$.pipe(delay(this.debounceTime), filter(Boolean)).subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        entry,\n        observer\n      }) {\n        const target = entry.target;\n        const isStillVisible = yield _this.isVisible(target);\n\n        if (isStillVisible) {\n          _this.visible.emit(target);\n        } else {\n          _this.invisible.emit(target);\n        } // if (isStillVisible) {\n        //   this.visible.emit(target);\n        //   observer.unobserve(target);\n        // }\n\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n}\n\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) {\n  return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: ObserveVisibilityDirective,\n  selectors: [[\"\", \"observeVisibility\", \"\"]],\n  inputs: {\n    debounceTime: \"debounceTime\",\n    threshold: \"threshold\"\n  },\n  outputs: {\n    visible: \"visible\",\n    invisible: \"invisible\"\n  }\n});","map":{"version":3,"sources":["C:/Users/sheme/Documents/GitHub/aorta_new_website/src/app/observe-visibility.directive.ts"],"names":["EventEmitter","delay","filter","Subject","i0","ObserveVisibilityDirective","constructor","element","debounceTime","threshold","visible","invisible","subject$","ngOnInit","createObserver","ngAfterViewInit","startObservingElements","ngOnDestroy","console","log","observer","disconnect","undefined","complete","isVisible","Promise","resolve","IntersectionObserver","entry","intersectionRatio","observe","options","rootMargin","isIntersecting","entries","forEach","next","nativeElement","pipe","Boolean","subscribe","target","isStillVisible","emit","ɵfac","ObserveVisibilityDirective_Factory","t","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","type","selectors","inputs","outputs"],"mappings":"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","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { delay, filter, Subject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class ObserveVisibilityDirective {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.debounceTime = 0;\r\n        this.threshold = 1;\r\n        this.visible = new EventEmitter();\r\n        this.invisible = new EventEmitter();\r\n        this.subject$ = new Subject();\r\n    }\r\n    ngOnInit() {\r\n        this.createObserver();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.startObservingElements();\r\n    }\r\n    ngOnDestroy() {\r\n        console.log('ngOnDestroy');\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = undefined;\r\n        }\r\n        // this.subject$.next();\r\n        this.subject$.complete();\r\n    }\r\n    isVisible(element) {\r\n        return new Promise(resolve => {\r\n            const observer = new IntersectionObserver(([entry]) => {\r\n                resolve(entry.intersectionRatio === 1);\r\n                observer.disconnect();\r\n            });\r\n            observer.observe(element);\r\n        });\r\n    }\r\n    createObserver() {\r\n        const options = {\r\n            rootMargin: '0px',\r\n            threshold: this.threshold,\r\n        };\r\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\r\n        this.observer = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                if (isIntersecting(entry)) {\r\n                    this.subject$.next({ entry, observer });\r\n                }\r\n            });\r\n        }, options);\r\n    }\r\n    startObservingElements() {\r\n        if (!this.observer) {\r\n            return;\r\n        }\r\n        this.observer.observe(this.element.nativeElement);\r\n        this.subject$\r\n            .pipe(delay(this.debounceTime), filter(Boolean))\r\n            .subscribe(async ({ entry, observer }) => {\r\n            const target = entry.target;\r\n            const isStillVisible = await this.isVisible(target);\r\n            if (isStillVisible) {\r\n                this.visible.emit(target);\r\n            }\r\n            else {\r\n                this.invisible.emit(target);\r\n            }\r\n            // if (isStillVisible) {\r\n            //   this.visible.emit(target);\r\n            //   observer.unobserve(target);\r\n            // }\r\n        });\r\n    }\r\n}\r\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) { return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\r\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ObserveVisibilityDirective, selectors: [[\"\", \"observeVisibility\", \"\"]], inputs: { debounceTime: \"debounceTime\", threshold: \"threshold\" }, outputs: { visible: \"visible\", invisible: \"invisible\" } });\r\n"]},"metadata":{},"sourceType":"module"}