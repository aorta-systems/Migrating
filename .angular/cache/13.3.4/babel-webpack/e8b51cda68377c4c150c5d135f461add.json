{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sheme\\\\Documents\\\\GitHub\\\\aorta_new_website\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { delay, debounceTime, filter, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class ObserveVisibilityDirective {\n  constructor(element) {\n    this.element = element;\n    this.debounceTime = 0;\n    this.delayTime = 0;\n    this.threshold = 1.0;\n    this.visible = new EventEmitter();\n    this.invisible = new EventEmitter();\n    this.subject$ = new Subject();\n    this.isNotVisible = false;\n    this.timestamp = 0;\n    this.options = {\n      rootMargin: '0px',\n      threshold: this.threshold\n    };\n  }\n\n  ngOnInit() {\n    // console.log('ngOnInit')\n    this.createObserver();\n  }\n\n  ngAfterViewInit() {\n    console.log('ngAfterViewInit');\n    this.startObservingElements();\n  }\n\n  ngOnDestroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n\n    this.subject$.complete();\n  }\n\n  startObservingElements() {\n    var _this = this;\n\n    if (!this.observer) {\n      return;\n    } // const isIntersecting = (entry: IntersectionObserverEntry) => entry.isIntersecting || entry.intersectionRatio > 0;\n    // this.observer = new IntersectionObserver(() => { },this.options);\n\n\n    console.log('this.element');\n    console.log(this.element.nativeElement);\n    this.observer.observe(this.element.nativeElement);\n    this.subject$.pipe( // tap((a) => console.log(\"tab:\" + a)),\n    delay(this.debounceTime), debounceTime(this.debounceTime), filter(({\n      entry,\n      observer\n    }) => {\n      return !!observer;\n    })).subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        entry,\n        observer\n      }) {\n        const target = entry.target;\n        const isStillVisible = yield _this.isVisible(target);\n        console.log('------target------');\n        console.log(target);\n        console.log(isStillVisible);\n\n        if (_this.isNotVisible !== isStillVisible) {\n          // const passEnaughtTimeFromPreviosRun = this.timestamp == null || (Date.now()/1000 - this.timestamp/1000) > this.delayTime\n          // if (isStillVisible && passEnaughtTimeFromPreviosRun) {\n          //   this.visible.emit(target);\n          // }\n          if (isStillVisible) {\n            console.log('------visible------');\n\n            _this.visible.emit(target);\n          } else {\n            console.log('------invisible------');\n\n            _this.invisible.emit(target);\n          } // else {\n          //   this.timestamp = Date.now() as number;\n          //   this.invisible.emit(target);\n          // }\n\n        }\n\n        _this.isNotVisible = isStillVisible; // console.log(isStillVisible)\n        // if (isStillVisible) {\n        //   this.visible.emit(target);\n        //   observer.unobserve(target);\n        // }\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  isVisible(element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        // console.log('entry.intersectionRatio ',  entry.intersectionRatio)\n        resolve(entry.intersectionRatio >= this.threshold);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  }\n\n  createObserver() {\n    // const options = {\n    //   rootMargin: '0px',\n    //   threshold: this.threshold,\n    // };\n    // const isIntersecting = (entry: IntersectionObserverEntry) => entry.isIntersecting || entry.intersectionRatio > 0;\n    // this.observer = new IntersectionObserver((entries, observer) => {\n    // }, options);\n    this.observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        console.log('entry.target');\n        console.log(entry.target);\n\n        if (entry.isIntersecting || entry.intersectionRatio > 0) {\n          // observer.unobserve(entry.target)\n          this.subject$.next({\n            entry,\n            observer\n          });\n        }\n      });\n    }, this.options);\n  }\n\n}\n\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) {\n  return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: ObserveVisibilityDirective,\n  selectors: [[\"\", \"observeVisibility\", \"\"]],\n  inputs: {\n    debounceTime: \"debounceTime\",\n    delayTime: \"delayTime\",\n    threshold: \"threshold\"\n  },\n  outputs: {\n    visible: \"visible\",\n    invisible: \"invisible\"\n  }\n});","map":{"version":3,"sources":["C:/Users/sheme/Documents/GitHub/aorta_new_website/src/app/observe-visibility.directive.ts"],"names":["EventEmitter","delay","debounceTime","filter","Subject","i0","ObserveVisibilityDirective","constructor","element","delayTime","threshold","visible","invisible","subject$","isNotVisible","timestamp","options","rootMargin","ngOnInit","createObserver","ngAfterViewInit","console","log","startObservingElements","ngOnDestroy","observer","disconnect","undefined","complete","nativeElement","observe","pipe","entry","subscribe","target","isStillVisible","isVisible","emit","Promise","resolve","IntersectionObserver","intersectionRatio","entries","forEach","isIntersecting","next","ɵfac","ObserveVisibilityDirective_Factory","t","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","type","selectors","inputs","outputs"],"mappings":";AAAA,SAASA,YAAT,QAA6B,eAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,EAA8BC,MAA9B,EAAsCC,OAAtC,QAAqD,MAArD;AACA,OAAO,KAAKC,EAAZ,MAAoB,eAApB;AACA,OAAO,MAAMC,0BAAN,CAAiC;AACpCC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKN,YAAL,GAAoB,CAApB;AACA,SAAKO,SAAL,GAAiB,CAAjB;AACA,SAAKC,SAAL,GAAiB,GAAjB;AACA,SAAKC,OAAL,GAAe,IAAIX,YAAJ,EAAf;AACA,SAAKY,SAAL,GAAiB,IAAIZ,YAAJ,EAAjB;AACA,SAAKa,QAAL,GAAgB,IAAIT,OAAJ,EAAhB;AACA,SAAKU,YAAL,GAAoB,KAApB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,OAAL,GAAe;AACXC,MAAAA,UAAU,EAAE,KADD;AAEXP,MAAAA,SAAS,EAAE,KAAKA;AAFL,KAAf;AAIH;;AACDQ,EAAAA,QAAQ,GAAG;AACP;AACA,SAAKC,cAAL;AACH;;AACDC,EAAAA,eAAe,GAAG;AACdC,IAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACA,SAAKC,sBAAL;AACH;;AACDC,EAAAA,WAAW,GAAG;AACV,QAAI,KAAKC,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAcC,UAAd;AACA,WAAKD,QAAL,GAAgBE,SAAhB;AACH;;AACD,SAAKd,QAAL,CAAce,QAAd;AACH;;AACDL,EAAAA,sBAAsB,GAAG;AAAA;;AACrB,QAAI,CAAC,KAAKE,QAAV,EAAoB;AAChB;AACH,KAHoB,CAIrB;AACA;;;AACAJ,IAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACAD,IAAAA,OAAO,CAACC,GAAR,CAAY,KAAKd,OAAL,CAAaqB,aAAzB;AACA,SAAKJ,QAAL,CAAcK,OAAd,CAAsB,KAAKtB,OAAL,CAAaqB,aAAnC;AACA,SAAKhB,QAAL,CACKkB,IADL,EAEA;AACA9B,IAAAA,KAAK,CAAC,KAAKC,YAAN,CAHL,EAG0BA,YAAY,CAAC,KAAKA,YAAN,CAHtC,EAG2DC,MAAM,CAAC,CAAC;AAAE6B,MAAAA,KAAF;AAASP,MAAAA;AAAT,KAAD,KAAyB;AACvF,aAAO,CAAC,CAACA,QAAT;AACH,KAFgE,CAHjE,EAMKQ,SANL;AAAA,mCAMe,WAAO;AAAED,QAAAA,KAAF;AAASP,QAAAA;AAAT,OAAP,EAA+B;AAC1C,cAAMS,MAAM,GAAGF,KAAK,CAACE,MAArB;AACA,cAAMC,cAAc,SAAS,KAAI,CAACC,SAAL,CAAeF,MAAf,CAA7B;AACAb,QAAAA,OAAO,CAACC,GAAR,CAAY,oBAAZ;AACAD,QAAAA,OAAO,CAACC,GAAR,CAAYY,MAAZ;AACAb,QAAAA,OAAO,CAACC,GAAR,CAAYa,cAAZ;;AACA,YAAI,KAAI,CAACrB,YAAL,KAAsBqB,cAA1B,EAA0C;AACtC;AACA;AACA;AACA;AACA,cAAIA,cAAJ,EAAoB;AAChBd,YAAAA,OAAO,CAACC,GAAR,CAAY,qBAAZ;;AACA,YAAA,KAAI,CAACX,OAAL,CAAa0B,IAAb,CAAkBH,MAAlB;AACH,WAHD,MAIK;AACDb,YAAAA,OAAO,CAACC,GAAR,CAAY,uBAAZ;;AACA,YAAA,KAAI,CAACV,SAAL,CAAeyB,IAAf,CAAoBH,MAApB;AACH,WAZqC,CAatC;AACA;AACA;AACA;;AACH;;AACD,QAAA,KAAI,CAACpB,YAAL,GAAoBqB,cAApB,CAxB0C,CAyB1C;AACA;AACA;AACA;AACA;AACH,OApCD;;AAAA;AAAA;AAAA;AAAA;AAqCH;;AACDC,EAAAA,SAAS,CAAC5B,OAAD,EAAU;AACf,WAAO,IAAI8B,OAAJ,CAAYC,OAAO,IAAI;AAC1B,YAAMd,QAAQ,GAAG,IAAIe,oBAAJ,CAAyB,CAAC,CAACR,KAAD,CAAD,KAAa;AACnD;AACAO,QAAAA,OAAO,CAACP,KAAK,CAACS,iBAAN,IAA2B,KAAK/B,SAAjC,CAAP;AACAe,QAAAA,QAAQ,CAACC,UAAT;AACH,OAJgB,CAAjB;AAKAD,MAAAA,QAAQ,CAACK,OAAT,CAAiBtB,OAAjB;AACH,KAPM,CAAP;AAQH;;AACDW,EAAAA,cAAc,GAAG;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAKM,QAAL,GAAgB,IAAIe,oBAAJ,CAAyB,CAACE,OAAD,EAAUjB,QAAV,KAAuB;AAC5DiB,MAAAA,OAAO,CAACC,OAAR,CAAgBX,KAAK,IAAI;AACrBX,QAAAA,OAAO,CAACC,GAAR,CAAY,cAAZ;AACAD,QAAAA,OAAO,CAACC,GAAR,CAAYU,KAAK,CAACE,MAAlB;;AACA,YAAIF,KAAK,CAACY,cAAN,IAAwBZ,KAAK,CAACS,iBAAN,GAA0B,CAAtD,EAAyD;AACrD;AACA,eAAK5B,QAAL,CAAcgC,IAAd,CAAmB;AAAEb,YAAAA,KAAF;AAASP,YAAAA;AAAT,WAAnB;AACH;AACJ,OAPD;AAQH,KATe,EASb,KAAKT,OATQ,CAAhB;AAUH;;AA1GmC;;AA4GxCV,0BAA0B,CAACwC,IAA3B,GAAkC,SAASC,kCAAT,CAA4CC,CAA5C,EAA+C;AAAE,SAAO,KAAKA,CAAC,IAAI1C,0BAAV,EAAsCD,EAAE,CAAC4C,iBAAH,CAAqB5C,EAAE,CAAC6C,UAAxB,CAAtC,CAAP;AAAoF,CAAvK;;AACA5C,0BAA0B,CAAC6C,IAA3B,GAAkC,aAAc9C,EAAE,CAAC+C,iBAAH,CAAqB;AAAEC,EAAAA,IAAI,EAAE/C,0BAAR;AAAoCgD,EAAAA,SAAS,EAAE,CAAC,CAAC,EAAD,EAAK,mBAAL,EAA0B,EAA1B,CAAD,CAA/C;AAAgFC,EAAAA,MAAM,EAAE;AAAErD,IAAAA,YAAY,EAAE,cAAhB;AAAgCO,IAAAA,SAAS,EAAE,WAA3C;AAAwDC,IAAAA,SAAS,EAAE;AAAnE,GAAxF;AAA0K8C,EAAAA,OAAO,EAAE;AAAE7C,IAAAA,OAAO,EAAE,SAAX;AAAsBC,IAAAA,SAAS,EAAE;AAAjC;AAAnL,CAArB,CAAhD","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { delay, debounceTime, filter, Subject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class ObserveVisibilityDirective {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.debounceTime = 0;\r\n        this.delayTime = 0;\r\n        this.threshold = 1.0;\r\n        this.visible = new EventEmitter();\r\n        this.invisible = new EventEmitter();\r\n        this.subject$ = new Subject();\r\n        this.isNotVisible = false;\r\n        this.timestamp = 0;\r\n        this.options = {\r\n            rootMargin: '0px',\r\n            threshold: this.threshold,\r\n        };\r\n    }\r\n    ngOnInit() {\r\n        // console.log('ngOnInit')\r\n        this.createObserver();\r\n    }\r\n    ngAfterViewInit() {\r\n        console.log('ngAfterViewInit');\r\n        this.startObservingElements();\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = undefined;\r\n        }\r\n        this.subject$.complete();\r\n    }\r\n    startObservingElements() {\r\n        if (!this.observer) {\r\n            return;\r\n        }\r\n        // const isIntersecting = (entry: IntersectionObserverEntry) => entry.isIntersecting || entry.intersectionRatio > 0;\r\n        // this.observer = new IntersectionObserver(() => { },this.options);\r\n        console.log('this.element');\r\n        console.log(this.element.nativeElement);\r\n        this.observer.observe(this.element.nativeElement);\r\n        this.subject$\r\n            .pipe(\r\n        // tap((a) => console.log(\"tab:\" + a)),\r\n        delay(this.debounceTime), debounceTime(this.debounceTime), filter(({ entry, observer }) => {\r\n            return !!observer;\r\n        }))\r\n            .subscribe(async ({ entry, observer }) => {\r\n            const target = entry.target;\r\n            const isStillVisible = await this.isVisible(target);\r\n            console.log('------target------');\r\n            console.log(target);\r\n            console.log(isStillVisible);\r\n            if (this.isNotVisible !== isStillVisible) {\r\n                // const passEnaughtTimeFromPreviosRun = this.timestamp == null || (Date.now()/1000 - this.timestamp/1000) > this.delayTime\r\n                // if (isStillVisible && passEnaughtTimeFromPreviosRun) {\r\n                //   this.visible.emit(target);\r\n                // }\r\n                if (isStillVisible) {\r\n                    console.log('------visible------');\r\n                    this.visible.emit(target);\r\n                }\r\n                else {\r\n                    console.log('------invisible------');\r\n                    this.invisible.emit(target);\r\n                }\r\n                // else {\r\n                //   this.timestamp = Date.now() as number;\r\n                //   this.invisible.emit(target);\r\n                // }\r\n            }\r\n            this.isNotVisible = isStillVisible;\r\n            // console.log(isStillVisible)\r\n            // if (isStillVisible) {\r\n            //   this.visible.emit(target);\r\n            //   observer.unobserve(target);\r\n            // }\r\n        });\r\n    }\r\n    isVisible(element) {\r\n        return new Promise(resolve => {\r\n            const observer = new IntersectionObserver(([entry]) => {\r\n                // console.log('entry.intersectionRatio ',  entry.intersectionRatio)\r\n                resolve(entry.intersectionRatio >= this.threshold);\r\n                observer.disconnect();\r\n            });\r\n            observer.observe(element);\r\n        });\r\n    }\r\n    createObserver() {\r\n        // const options = {\r\n        //   rootMargin: '0px',\r\n        //   threshold: this.threshold,\r\n        // };\r\n        // const isIntersecting = (entry: IntersectionObserverEntry) => entry.isIntersecting || entry.intersectionRatio > 0;\r\n        // this.observer = new IntersectionObserver((entries, observer) => {\r\n        // }, options);\r\n        this.observer = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                console.log('entry.target');\r\n                console.log(entry.target);\r\n                if (entry.isIntersecting || entry.intersectionRatio > 0) {\r\n                    // observer.unobserve(entry.target)\r\n                    this.subject$.next({ entry, observer });\r\n                }\r\n            });\r\n        }, this.options);\r\n    }\r\n}\r\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) { return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\r\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ObserveVisibilityDirective, selectors: [[\"\", \"observeVisibility\", \"\"]], inputs: { debounceTime: \"debounceTime\", delayTime: \"delayTime\", threshold: \"threshold\" }, outputs: { visible: \"visible\", invisible: \"invisible\" } });\r\n"]},"metadata":{},"sourceType":"module"}