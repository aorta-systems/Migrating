{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sheme\\\\Documents\\\\GitHub\\\\aorta_new_website\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { delay, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class ObserveVisibilityDirective {\n  constructor(element) {\n    this.element = element;\n    this.debounceTime = 0;\n    this.delayTime = 0;\n    this.threshold = 1.0;\n    this.visible = new EventEmitter();\n    this.invisible = new EventEmitter();\n    this.subject$ = new Subject();\n    this.isNotVisible = false;\n    this.timestamp = 0;\n  }\n\n  ngOnInit() {\n    console.log('ngOnInit');\n    this.createObserver();\n  }\n\n  ngAfterViewInit() {\n    console.log('ngAfterViewInit');\n    this.startObservingElements();\n  }\n\n  ngOnDestroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n\n    this.subject$.complete();\n  }\n\n  startObservingElements() {\n    var _this = this;\n\n    if (!this.observer) {\n      return;\n    }\n\n    console.log('this.element');\n    console.log(this.element.nativeElement);\n    this.observer.observe(this.element.nativeElement);\n    this.subject$.pipe( // tap((a) => console.log(\"tab:\" + a)),\n    delay(this.debounceTime)).subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        entry,\n        observer\n      }) {\n        console.log(entry.target);\n        console.log(_this.timestamp);\n        const target = entry.target;\n        const isStillVisible = yield _this.isVisible(target);\n\n        if (_this.isNotVisible !== isStillVisible) {\n          const passEnaughtTimeFromPreviosRun = _this.timestamp == null || Date.now() / 1000 - _this.timestamp / 1000 > _this.delayTime;\n\n          if (isStillVisible && passEnaughtTimeFromPreviosRun) {\n            _this.visible.emit(target);\n          } // else {\n          //   this.timestamp = Date.now() as number;\n          //   this.invisible.emit(target);\n          // }\n\n        }\n\n        _this.isNotVisible = isStillVisible; // console.log(isStillVisible)\n        // if (isStillVisible) {\n        //   this.visible.emit(target);\n        //   observer.unobserve(target);\n        // }\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  isVisible(element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        // console.log('entry.intersectionRatio ',  entry.intersectionRatio)\n        resolve(entry.intersectionRatio >= this.threshold);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  }\n\n  createObserver() {\n    const options = {\n      rootMargin: '0px',\n      threshold: this.threshold\n    };\n\n    const isIntersecting = entry => entry.isIntersecting || entry.intersectionRatio > 0;\n\n    this.observer = new IntersectionObserver((entries, observer) => {}, options); // this.observer = new IntersectionObserver((entries, observer) => {\n    //   entries.forEach(entry => {\n    //     console.log('entry.target')\n    //     console.log(entry.target)\n    //     if (isIntersecting(entry)) {\n    //       this.subject$.next({ entry, observer });\n    //     }\n    //   });\n    // }, options);\n  }\n\n}\n\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) {\n  return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: ObserveVisibilityDirective,\n  selectors: [[\"\", \"observeVisibility\", \"\"]],\n  inputs: {\n    debounceTime: \"debounceTime\",\n    delayTime: \"delayTime\",\n    threshold: \"threshold\"\n  },\n  outputs: {\n    visible: \"visible\",\n    invisible: \"invisible\"\n  }\n});","map":{"version":3,"sources":["C:/Users/sheme/Documents/GitHub/aorta_new_website/src/app/observe-visibility.directive.ts"],"names":["EventEmitter","delay","Subject","i0","ObserveVisibilityDirective","constructor","element","debounceTime","delayTime","threshold","visible","invisible","subject$","isNotVisible","timestamp","ngOnInit","console","log","createObserver","ngAfterViewInit","startObservingElements","ngOnDestroy","observer","disconnect","undefined","complete","nativeElement","observe","pipe","subscribe","entry","target","isStillVisible","isVisible","passEnaughtTimeFromPreviosRun","Date","now","emit","Promise","resolve","IntersectionObserver","intersectionRatio","options","rootMargin","isIntersecting","entries","ɵfac","ObserveVisibilityDirective_Factory","t","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","type","selectors","inputs","outputs"],"mappings":"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","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { delay, Subject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class ObserveVisibilityDirective {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.debounceTime = 0;\r\n        this.delayTime = 0;\r\n        this.threshold = 1.0;\r\n        this.visible = new EventEmitter();\r\n        this.invisible = new EventEmitter();\r\n        this.subject$ = new Subject();\r\n        this.isNotVisible = false;\r\n        this.timestamp = 0;\r\n    }\r\n    ngOnInit() {\r\n        console.log('ngOnInit');\r\n        this.createObserver();\r\n    }\r\n    ngAfterViewInit() {\r\n        console.log('ngAfterViewInit');\r\n        this.startObservingElements();\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = undefined;\r\n        }\r\n        this.subject$.complete();\r\n    }\r\n    startObservingElements() {\r\n        if (!this.observer) {\r\n            return;\r\n        }\r\n        console.log('this.element');\r\n        console.log(this.element.nativeElement);\r\n        this.observer.observe(this.element.nativeElement);\r\n        this.subject$\r\n            .pipe(\r\n        // tap((a) => console.log(\"tab:\" + a)),\r\n        delay(this.debounceTime))\r\n            .subscribe(async ({ entry, observer }) => {\r\n            console.log(entry.target);\r\n            console.log(this.timestamp);\r\n            const target = entry.target;\r\n            const isStillVisible = await this.isVisible(target);\r\n            if (this.isNotVisible !== isStillVisible) {\r\n                const passEnaughtTimeFromPreviosRun = this.timestamp == null || (Date.now() / 1000 - this.timestamp / 1000) > this.delayTime;\r\n                if (isStillVisible && passEnaughtTimeFromPreviosRun) {\r\n                    this.visible.emit(target);\r\n                }\r\n                // else {\r\n                //   this.timestamp = Date.now() as number;\r\n                //   this.invisible.emit(target);\r\n                // }\r\n            }\r\n            this.isNotVisible = isStillVisible;\r\n            // console.log(isStillVisible)\r\n            // if (isStillVisible) {\r\n            //   this.visible.emit(target);\r\n            //   observer.unobserve(target);\r\n            // }\r\n        });\r\n    }\r\n    isVisible(element) {\r\n        return new Promise(resolve => {\r\n            const observer = new IntersectionObserver(([entry]) => {\r\n                // console.log('entry.intersectionRatio ',  entry.intersectionRatio)\r\n                resolve(entry.intersectionRatio >= this.threshold);\r\n                observer.disconnect();\r\n            });\r\n            observer.observe(element);\r\n        });\r\n    }\r\n    createObserver() {\r\n        const options = {\r\n            rootMargin: '0px',\r\n            threshold: this.threshold,\r\n        };\r\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\r\n        this.observer = new IntersectionObserver((entries, observer) => {\r\n        }, options);\r\n        // this.observer = new IntersectionObserver((entries, observer) => {\r\n        //   entries.forEach(entry => {\r\n        //     console.log('entry.target')\r\n        //     console.log(entry.target)\r\n        //     if (isIntersecting(entry)) {\r\n        //       this.subject$.next({ entry, observer });\r\n        //     }\r\n        //   });\r\n        // }, options);\r\n    }\r\n}\r\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) { return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\r\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ObserveVisibilityDirective, selectors: [[\"\", \"observeVisibility\", \"\"]], inputs: { debounceTime: \"debounceTime\", delayTime: \"delayTime\", threshold: \"threshold\" }, outputs: { visible: \"visible\", invisible: \"invisible\" } });\r\n"]},"metadata":{},"sourceType":"module"}