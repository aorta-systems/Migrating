{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sheme\\\\Documents\\\\GitHub\\\\aorta_new_website\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { delay, debounceTime, filter, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class ObserveVisibilityDirective {\n  constructor(element) {\n    this.element = element;\n    this.debounceTime = 0;\n    this.delayTime = 0;\n    this.threshold = 1.0;\n    this.visible = new EventEmitter();\n    this.invisible = new EventEmitter();\n    this.subject$ = new Subject();\n    this.isNotVisible = false;\n    this.timestamp = 0;\n    this.options = {\n      rootMargin: '0px',\n      threshold: this.threshold\n    };\n  }\n\n  ngOnInit() {\n    this.createObserver();\n  }\n\n  ngAfterViewInit() {\n    this.startObservingElements();\n  }\n\n  ngOnDestroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n\n    this.subject$.complete();\n  }\n\n  startObservingElements() {\n    var _this = this;\n\n    if (!this.observer) {\n      return;\n    }\n\n    this.observer.observe(this.element.nativeElement);\n    this.subject$.pipe(delay(150), debounceTime(this.debounceTime), filter(({\n      entry,\n      observer\n    }) => {\n      return !!observer;\n    })).subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        entry,\n        observer\n      }) {\n        const target = entry.target;\n        const isStillVisible = yield _this.isVisible(target);\n\n        if (_this.isNotVisible !== isStillVisible) {\n          if (isStillVisible) {\n            _this.visible.emit(target);\n          } else {\n            _this.invisible.emit(target);\n          }\n        }\n\n        _this.isNotVisible = isStillVisible;\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n  isVisible(element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        resolve(entry.intersectionRatio >= this.threshold);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  }\n\n  createObserver() {\n    this.observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        if (entry.isIntersecting || entry.intersectionRatio > 0) {\n          this.subject$.next({\n            entry,\n            observer\n          });\n        }\n      });\n    }, this.options);\n  }\n\n}\n\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) {\n  return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: ObserveVisibilityDirective,\n  selectors: [[\"\", \"observeVisibility\", \"\"]],\n  inputs: {\n    debounceTime: \"debounceTime\",\n    delayTime: \"delayTime\",\n    threshold: \"threshold\"\n  },\n  outputs: {\n    visible: \"visible\",\n    invisible: \"invisible\"\n  }\n});","map":{"version":3,"sources":["C:/Users/sheme/Documents/GitHub/aorta_new_website/src/app/observe-visibility.directive.ts"],"names":["EventEmitter","delay","debounceTime","filter","Subject","i0","ObserveVisibilityDirective","constructor","element","delayTime","threshold","visible","invisible","subject$","isNotVisible","timestamp","options","rootMargin","ngOnInit","createObserver","ngAfterViewInit","startObservingElements","ngOnDestroy","observer","disconnect","undefined","complete","observe","nativeElement","pipe","entry","subscribe","target","isStillVisible","isVisible","emit","Promise","resolve","IntersectionObserver","intersectionRatio","entries","forEach","isIntersecting","next","ɵfac","ObserveVisibilityDirective_Factory","t","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","type","selectors","inputs","outputs"],"mappings":";AAAA,SAASA,YAAT,QAA6B,eAA7B;AACA,SAASC,KAAT,EAAgBC,YAAhB,EAA8BC,MAA9B,EAAsCC,OAAtC,QAAqD,MAArD;AACA,OAAO,KAAKC,EAAZ,MAAoB,eAApB;AACA,OAAO,MAAMC,0BAAN,CAAiC;AACpCC,EAAAA,WAAW,CAACC,OAAD,EAAU;AACjB,SAAKA,OAAL,GAAeA,OAAf;AACA,SAAKN,YAAL,GAAoB,CAApB;AACA,SAAKO,SAAL,GAAiB,CAAjB;AACA,SAAKC,SAAL,GAAiB,GAAjB;AACA,SAAKC,OAAL,GAAe,IAAIX,YAAJ,EAAf;AACA,SAAKY,SAAL,GAAiB,IAAIZ,YAAJ,EAAjB;AACA,SAAKa,QAAL,GAAgB,IAAIT,OAAJ,EAAhB;AACA,SAAKU,YAAL,GAAoB,KAApB;AACA,SAAKC,SAAL,GAAiB,CAAjB;AACA,SAAKC,OAAL,GAAe;AACXC,MAAAA,UAAU,EAAE,KADD;AAEXP,MAAAA,SAAS,EAAE,KAAKA;AAFL,KAAf;AAIH;;AACDQ,EAAAA,QAAQ,GAAG;AACP,SAAKC,cAAL;AACH;;AACDC,EAAAA,eAAe,GAAG;AACd,SAAKC,sBAAL;AACH;;AACDC,EAAAA,WAAW,GAAG;AACV,QAAI,KAAKC,QAAT,EAAmB;AACf,WAAKA,QAAL,CAAcC,UAAd;AACA,WAAKD,QAAL,GAAgBE,SAAhB;AACH;;AACD,SAAKZ,QAAL,CAAca,QAAd;AACH;;AACDL,EAAAA,sBAAsB,GAAG;AAAA;;AACrB,QAAI,CAAC,KAAKE,QAAV,EAAoB;AAChB;AACH;;AACD,SAAKA,QAAL,CAAcI,OAAd,CAAsB,KAAKnB,OAAL,CAAaoB,aAAnC;AACA,SAAKf,QAAL,CACKgB,IADL,CACU5B,KAAK,CAAC,GAAD,CADf,EACsBC,YAAY,CAAC,KAAKA,YAAN,CADlC,EACuDC,MAAM,CAAC,CAAC;AAAE2B,MAAAA,KAAF;AAASP,MAAAA;AAAT,KAAD,KAAyB;AACnF,aAAO,CAAC,CAACA,QAAT;AACH,KAF4D,CAD7D,EAIKQ,SAJL;AAAA,mCAIe,WAAO;AAAED,QAAAA,KAAF;AAASP,QAAAA;AAAT,OAAP,EAA+B;AAC1C,cAAMS,MAAM,GAAGF,KAAK,CAACE,MAArB;AACA,cAAMC,cAAc,SAAS,KAAI,CAACC,SAAL,CAAeF,MAAf,CAA7B;;AACA,YAAI,KAAI,CAAClB,YAAL,KAAsBmB,cAA1B,EAA0C;AACtC,cAAIA,cAAJ,EAAoB;AAChB,YAAA,KAAI,CAACtB,OAAL,CAAawB,IAAb,CAAkBH,MAAlB;AACH,WAFD,MAGK;AACD,YAAA,KAAI,CAACpB,SAAL,CAAeuB,IAAf,CAAoBH,MAApB;AACH;AACJ;;AACD,QAAA,KAAI,CAAClB,YAAL,GAAoBmB,cAApB;AACH,OAhBD;;AAAA;AAAA;AAAA;AAAA;AAiBH;;AACDC,EAAAA,SAAS,CAAC1B,OAAD,EAAU;AACf,WAAO,IAAI4B,OAAJ,CAAYC,OAAO,IAAI;AAC1B,YAAMd,QAAQ,GAAG,IAAIe,oBAAJ,CAAyB,CAAC,CAACR,KAAD,CAAD,KAAa;AACnDO,QAAAA,OAAO,CAACP,KAAK,CAACS,iBAAN,IAA2B,KAAK7B,SAAjC,CAAP;AACAa,QAAAA,QAAQ,CAACC,UAAT;AACH,OAHgB,CAAjB;AAIAD,MAAAA,QAAQ,CAACI,OAAT,CAAiBnB,OAAjB;AACH,KANM,CAAP;AAOH;;AACDW,EAAAA,cAAc,GAAG;AACb,SAAKI,QAAL,GAAgB,IAAIe,oBAAJ,CAAyB,CAACE,OAAD,EAAUjB,QAAV,KAAuB;AAC5DiB,MAAAA,OAAO,CAACC,OAAR,CAAgBX,KAAK,IAAI;AACrB,YAAIA,KAAK,CAACY,cAAN,IAAwBZ,KAAK,CAACS,iBAAN,GAA0B,CAAtD,EAAyD;AACrD,eAAK1B,QAAL,CAAc8B,IAAd,CAAmB;AAAEb,YAAAA,KAAF;AAASP,YAAAA;AAAT,WAAnB;AACH;AACJ,OAJD;AAKH,KANe,EAMb,KAAKP,OANQ,CAAhB;AAOH;;AArEmC;;AAuExCV,0BAA0B,CAACsC,IAA3B,GAAkC,SAASC,kCAAT,CAA4CC,CAA5C,EAA+C;AAAE,SAAO,KAAKA,CAAC,IAAIxC,0BAAV,EAAsCD,EAAE,CAAC0C,iBAAH,CAAqB1C,EAAE,CAAC2C,UAAxB,CAAtC,CAAP;AAAoF,CAAvK;;AACA1C,0BAA0B,CAAC2C,IAA3B,GAAkC,aAAc5C,EAAE,CAAC6C,iBAAH,CAAqB;AAAEC,EAAAA,IAAI,EAAE7C,0BAAR;AAAoC8C,EAAAA,SAAS,EAAE,CAAC,CAAC,EAAD,EAAK,mBAAL,EAA0B,EAA1B,CAAD,CAA/C;AAAgFC,EAAAA,MAAM,EAAE;AAAEnD,IAAAA,YAAY,EAAE,cAAhB;AAAgCO,IAAAA,SAAS,EAAE,WAA3C;AAAwDC,IAAAA,SAAS,EAAE;AAAnE,GAAxF;AAA0K4C,EAAAA,OAAO,EAAE;AAAE3C,IAAAA,OAAO,EAAE,SAAX;AAAsBC,IAAAA,SAAS,EAAE;AAAjC;AAAnL,CAArB,CAAhD","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { delay, debounceTime, filter, Subject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class ObserveVisibilityDirective {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.debounceTime = 0;\r\n        this.delayTime = 0;\r\n        this.threshold = 1.0;\r\n        this.visible = new EventEmitter();\r\n        this.invisible = new EventEmitter();\r\n        this.subject$ = new Subject();\r\n        this.isNotVisible = false;\r\n        this.timestamp = 0;\r\n        this.options = {\r\n            rootMargin: '0px',\r\n            threshold: this.threshold,\r\n        };\r\n    }\r\n    ngOnInit() {\r\n        this.createObserver();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.startObservingElements();\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = undefined;\r\n        }\r\n        this.subject$.complete();\r\n    }\r\n    startObservingElements() {\r\n        if (!this.observer) {\r\n            return;\r\n        }\r\n        this.observer.observe(this.element.nativeElement);\r\n        this.subject$\r\n            .pipe(delay(150), debounceTime(this.debounceTime), filter(({ entry, observer }) => {\r\n            return !!observer;\r\n        }))\r\n            .subscribe(async ({ entry, observer }) => {\r\n            const target = entry.target;\r\n            const isStillVisible = await this.isVisible(target);\r\n            if (this.isNotVisible !== isStillVisible) {\r\n                if (isStillVisible) {\r\n                    this.visible.emit(target);\r\n                }\r\n                else {\r\n                    this.invisible.emit(target);\r\n                }\r\n            }\r\n            this.isNotVisible = isStillVisible;\r\n        });\r\n    }\r\n    isVisible(element) {\r\n        return new Promise(resolve => {\r\n            const observer = new IntersectionObserver(([entry]) => {\r\n                resolve(entry.intersectionRatio >= this.threshold);\r\n                observer.disconnect();\r\n            });\r\n            observer.observe(element);\r\n        });\r\n    }\r\n    createObserver() {\r\n        this.observer = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                if (entry.isIntersecting || entry.intersectionRatio > 0) {\r\n                    this.subject$.next({ entry, observer });\r\n                }\r\n            });\r\n        }, this.options);\r\n    }\r\n}\r\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) { return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\r\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ObserveVisibilityDirective, selectors: [[\"\", \"observeVisibility\", \"\"]], inputs: { debounceTime: \"debounceTime\", delayTime: \"delayTime\", threshold: \"threshold\" }, outputs: { visible: \"visible\", invisible: \"invisible\" } });\r\n"]},"metadata":{},"sourceType":"module"}