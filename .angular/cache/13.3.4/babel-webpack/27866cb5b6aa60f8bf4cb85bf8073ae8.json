{"ast":null,"code":"import _asyncToGenerator from \"C:\\\\Users\\\\sheme\\\\Documents\\\\GitHub\\\\aorta_new_website\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\asyncToGenerator.js\";\nimport { EventEmitter } from '@angular/core';\nimport { delay, filter, Subject } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class ObserveVisibilityDirective {\n  constructor(element) {\n    this.element = element;\n    this.debounceTime = 0;\n    this.delayTime = 0;\n    this.threshold = 1.0;\n    this.visible = new EventEmitter();\n    this.invisible = new EventEmitter();\n    this.subject$ = new Subject();\n  }\n\n  ngOnInit() {\n    this.createObserver();\n  }\n\n  ngAfterViewInit() {\n    this.startObservingElements();\n  }\n\n  ngOnDestroy() {\n    if (this.observer) {\n      this.observer.disconnect();\n      this.observer = undefined;\n    }\n\n    this.subject$.complete();\n  }\n\n  isVisible(element) {\n    return new Promise(resolve => {\n      const observer = new IntersectionObserver(([entry]) => {\n        console.log('entry.intersectionRatio ', entry.intersectionRatio);\n        resolve(entry.intersectionRatio >= this.threshold);\n        observer.disconnect();\n      });\n      observer.observe(element);\n    });\n  }\n\n  createObserver() {\n    const options = {\n      rootMargin: '0px',\n      threshold: this.threshold\n    };\n\n    const isIntersecting = entry => entry.isIntersecting || entry.intersectionRatio > 0;\n\n    this.observer = new IntersectionObserver((entries, observer) => {\n      entries.forEach(entry => {\n        console.log('entry.target');\n        console.log(entry.target);\n\n        if (isIntersecting(entry)) {\n          this.subject$.next({\n            entry,\n            observer\n          });\n        }\n      });\n    }, options);\n  }\n\n  startObservingElements() {\n    var _this = this;\n\n    if (!this.observer) {\n      return;\n    }\n\n    console.log('this.element');\n    console.log(this.element.nativeElement);\n    this.observer.observe(this.element.nativeElement);\n    this.subject$.pipe(delay(this.debounceTime), filter(Boolean)).subscribe( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* ({\n        entry,\n        observer\n      }) {\n        console.log(entry.target);\n        const target = entry.target;\n        const isStillVisible = yield _this.isVisible(target);\n        console.log(isStillVisible);\n\n        if (isStillVisible) {\n          _this.visible.emit(target);\n        } else {\n          _this.invisible.emit(target);\n        } // if (isStillVisible) {\n        //   this.visible.emit(target);\n        //   observer.unobserve(target);\n        // }\n\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }());\n  }\n\n}\n\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) {\n  return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef));\n};\n\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/i0.ɵɵdefineDirective({\n  type: ObserveVisibilityDirective,\n  selectors: [[\"\", \"observeVisibility\", \"\"]],\n  inputs: {\n    debounceTime: \"debounceTime\",\n    delayTime: \"delayTime\",\n    threshold: \"threshold\"\n  },\n  outputs: {\n    visible: \"visible\",\n    invisible: \"invisible\"\n  }\n});","map":{"version":3,"sources":["C:/Users/sheme/Documents/GitHub/aorta_new_website/src/app/observe-visibility.directive.ts"],"names":["EventEmitter","delay","filter","Subject","i0","ObserveVisibilityDirective","constructor","element","debounceTime","delayTime","threshold","visible","invisible","subject$","ngOnInit","createObserver","ngAfterViewInit","startObservingElements","ngOnDestroy","observer","disconnect","undefined","complete","isVisible","Promise","resolve","IntersectionObserver","entry","console","log","intersectionRatio","observe","options","rootMargin","isIntersecting","entries","forEach","target","next","nativeElement","pipe","Boolean","subscribe","isStillVisible","emit","ɵfac","ObserveVisibilityDirective_Factory","t","ɵɵdirectiveInject","ElementRef","ɵdir","ɵɵdefineDirective","type","selectors","inputs","outputs"],"mappings":"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","sourcesContent":["import { EventEmitter } from '@angular/core';\r\nimport { delay, filter, Subject } from 'rxjs';\r\nimport * as i0 from \"@angular/core\";\r\nexport class ObserveVisibilityDirective {\r\n    constructor(element) {\r\n        this.element = element;\r\n        this.debounceTime = 0;\r\n        this.delayTime = 0;\r\n        this.threshold = 1.0;\r\n        this.visible = new EventEmitter();\r\n        this.invisible = new EventEmitter();\r\n        this.subject$ = new Subject();\r\n    }\r\n    ngOnInit() {\r\n        this.createObserver();\r\n    }\r\n    ngAfterViewInit() {\r\n        this.startObservingElements();\r\n    }\r\n    ngOnDestroy() {\r\n        if (this.observer) {\r\n            this.observer.disconnect();\r\n            this.observer = undefined;\r\n        }\r\n        this.subject$.complete();\r\n    }\r\n    isVisible(element) {\r\n        return new Promise(resolve => {\r\n            const observer = new IntersectionObserver(([entry]) => {\r\n                console.log('entry.intersectionRatio ', entry.intersectionRatio);\r\n                resolve(entry.intersectionRatio >= this.threshold);\r\n                observer.disconnect();\r\n            });\r\n            observer.observe(element);\r\n        });\r\n    }\r\n    createObserver() {\r\n        const options = {\r\n            rootMargin: '0px',\r\n            threshold: this.threshold,\r\n        };\r\n        const isIntersecting = (entry) => entry.isIntersecting || entry.intersectionRatio > 0;\r\n        this.observer = new IntersectionObserver((entries, observer) => {\r\n            entries.forEach(entry => {\r\n                console.log('entry.target');\r\n                console.log(entry.target);\r\n                if (isIntersecting(entry)) {\r\n                    this.subject$.next({ entry, observer });\r\n                }\r\n            });\r\n        }, options);\r\n    }\r\n    startObservingElements() {\r\n        if (!this.observer) {\r\n            return;\r\n        }\r\n        console.log('this.element');\r\n        console.log(this.element.nativeElement);\r\n        this.observer.observe(this.element.nativeElement);\r\n        this.subject$\r\n            .pipe(delay(this.debounceTime), filter(Boolean))\r\n            .subscribe(async ({ entry, observer }) => {\r\n            console.log(entry.target);\r\n            const target = entry.target;\r\n            const isStillVisible = await this.isVisible(target);\r\n            console.log(isStillVisible);\r\n            if (isStillVisible) {\r\n                this.visible.emit(target);\r\n            }\r\n            else {\r\n                this.invisible.emit(target);\r\n            }\r\n            // if (isStillVisible) {\r\n            //   this.visible.emit(target);\r\n            //   observer.unobserve(target);\r\n            // }\r\n        });\r\n    }\r\n}\r\nObserveVisibilityDirective.ɵfac = function ObserveVisibilityDirective_Factory(t) { return new (t || ObserveVisibilityDirective)(i0.ɵɵdirectiveInject(i0.ElementRef)); };\r\nObserveVisibilityDirective.ɵdir = /*@__PURE__*/ i0.ɵɵdefineDirective({ type: ObserveVisibilityDirective, selectors: [[\"\", \"observeVisibility\", \"\"]], inputs: { debounceTime: \"debounceTime\", delayTime: \"delayTime\", threshold: \"threshold\" }, outputs: { visible: \"visible\", invisible: \"invisible\" } });\r\n"]},"metadata":{},"sourceType":"module"}